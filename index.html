<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>TrabalhoICG by SoaresGabriel</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">TrabalhoICG</h1>
      <h2 class="project-tagline">Rasterização de Primitivas</h2>
      <a href="https://github.com/SoaresGabriel/TrabalhoICG" class="btn">View on GitHub</a>
      <a href="https://github.com/SoaresGabriel/TrabalhoICG/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/SoaresGabriel/TrabalhoICG/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h2>
<a id="introdução" class="anchor" href="#introdu%C3%A7%C3%A3o" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Introdução</h2>

<p>Este post faz parte do primeiro trabalho da disciplina Introdução à Computação Gráfica, ministrada pelo Prof. Christian Azambuja Pagot da UFPB, no período 2016.1.</p>

<p>Deve ser implementado um algoritmo para rasterização de pontos, linhas e triângulos, para isso, será usado um framework disponibilizado pelo próprio professor, que simula o acesso a memória, mais especificamente simula acesso ao ColorBuffer do FrameBuffer, onde fica as informações da imagem que aparece na tela do computador.</p>

<h3>
<a id="pixels" class="anchor" href="#pixels" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Pixels</h3>

<p>Os monitores exibem as imagens através de um conjuntos de pontos, chamados de pixel, dessa forma, um monitor tem W pixels de largura e H pixels de altura, como se fosse uma matriz W por H. </p>

<p>Cada pixel é representado na memória por um conjunto de 4 bytes, onde o primeiro dizemos que é o byte R(de red, vermelho), o segundo é o G(de green, verde), o terceiro é o B(de blue, azul), e o ultimo o A(alpha, controla a opacidade/transparência), com a combinação destes, podemos formar uma grande porção das cores visíveis ao olho humano. Como cada componente tem 1 byte (8 bits), ela pode assumir 256 valores diferentes que é na faixa de 0 a 255.</p>

<p><img src="https://soaresgabriel.github.io/TrabalhoICG/images/pixelscreen.png" alt="Composição de um Pixel"></p>

<p>Os pixels são distribuídos na tela como uma matriz (bi-dimensional), mas na memoria eles são armazenados linearmente, de forma que os bytes dos pixeis da segunda linha são armazenados logo após os da primeira e assim sucessivamente. Há uma região reservada da memoria em que esses bytes são gravados, que é chamada de ColorBuffer.</p>

<p>Dessa forma tendo as coordenadas x e y de um pixel, podemos encontrar sua posição na memória através da expressão <code>x*4 + y*W*4</code>, onde a posição 0 indica primeira posição do ColorBuffer(e não da memoria em si).</p>

<p><img src="https://soaresgabriel.github.io/TrabalhoICG/images/screenpixel.png" alt="Pixel na memória"></p>

<h3>
<a id="representação-de-primitivas" class="anchor" href="#representa%C3%A7%C3%A3o-de-primitivas" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Representação de Primitivas</h3>

<p>Obviamente um monitor pode comportar um número limitado de pixels, então qualquer objeto que queiramos mostrar em uma tela, será formado por um conjunto finito de pixels. </p>

<p>Mas uma reta, por exemplo, é um objeto contínuo: pegando um ponto da reta, não conseguimos definir qual é o próximo ponto, pois entre quaisquer dois pontos de uma reta, existem infinitos pontos, não importa o quão próximos eles estejam. Dessa forma, para desenhar uma reta outro objeto continuo em uma tela, precisamos criar uma aproximação discreta que poderá ser representada por um conjunto finito de pontos, esse processo é chamado de <strong>rasterização</strong>.</p>

<h1>
<a id="desenvolvimento-do-projeto" class="anchor" href="#desenvolvimento-do-projeto" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Desenvolvimento do Projeto</h1>

<p>Com essa noção básica, podemos começar a desenvolver o projeto, ele consiste basicamente em desenvolver três funções:</p>

<ul>
<li>
<strong>putPixel</strong> - Rasterizar ponto (ou Pixel), com sua devida cor.</li>
<li>
<strong>drawLine</strong> - Rasterizar linha, deve ter interpolação linear de cores</li>
<li>
<strong>drawTriangle</strong> - Rasterizar triângulo</li>
</ul>

<p>Para simplificar, na implementação foi definido algumas estruturas básicas:</p>

<ul>
<li>
<strong>Color</strong> - Composta por suas componentes RGBA</li>
<li>
<strong>Pixel</strong> - Tem as coordenadas x, y, e a cor (tipo Color).</li>
<li>
<strong>Line</strong> - Formada por dois Pixels, que são suas extremidades</li>
<li>
<strong>Triangle</strong> - Composta por 3 Pixels que representam seus vértices</li>
</ul>

<h2>
<a id="rasterização-de-pontos---putpixel" class="anchor" href="#rasteriza%C3%A7%C3%A3o-de-pontos---putpixel" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Rasterização de Pontos - putPixel</h2>

<p>Já sabemos como os pixels são armazenados na memória, também vimos como calcular o endereço de memoria de um pixel. No framework disponibilizado pelo professor temos o ponteiro FBptr que aponta para o endereço do primeiro byte do ColorBuffer(simulado). Com tudo isso em mãos, fica fácil implementar o putPixel: Calculamos o endereço do pixel com a expressão vista anteriormente, <code>e = x*4 + y*W*4</code>, e adicionamos ao ponteiro FBptr, para obter a posição do primeiro byte do pixel, e como ele é composto por 4 bytes, uma para cada componente, ficamos com (usaremos notação de array por conveniência):</p>

<ul>
<li>Fbptr[e+0] - Aqui escrevemos o valor da componente R da cor do pixel</li>
<li>Fbptr[e+1] - Da mesma forma, escrevemos aqui o valor a componente G</li>
<li>Fbptr[e+2] - Aqui vai a componente B</li>
<li>Fbptr[e+3] - E por último o A
Após escrevermos essas componentes já temos nosso pixel desenhado.</li>
</ul>

<h2>
<a id="rasterização-de-linhas---drawline" class="anchor" href="#rasteriza%C3%A7%C3%A3o-de-linhas---drawline" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Rasterização de Linhas - drawLine</h2>

<p>Agora desenvolveremos um método para desenhar uma linha na tela, precisamos ter algumas coisas em mente:</p>

<ul>
<li>Uma reta é um objeto continuo, então o que vamos criar é uma aproximação de uma reta em um espaço discreto, formado por pixels.</li>
<li>Uma reta ideal não tem espessura(apenas suas representações gráficas), portanto na tela, ela deve ser formada pela menor quantidade de pixels possíveis, desde que não comprometam sua representatividade. </li>
<li>Numa situação real, uma função de desenhar linhas, seria usada com bastante frequência, então ela deve ser o mais eficiente possível (precisar de menos recurso computacional).</li>
</ul>

<p>Por enquanto nos limitaremos ao problema de rasterizar linhas de 0° a 45°, e levaremos em consideração que os pixels tem coordenadas como no plano cartesiano (eixo x positivo para direita, eixo y positivo para cima). Vejamos o seguinte exemplo:</p>

<p><img src="https://soaresgabriel.github.io/TrabalhoICG/images/linepixel.png" alt="Linha em Pixels"></p>

<p>Sabemos que temos que "pintar" o primeiro e último pixel, mas quais pixeis pintar no meio do caminho? Lembrando que a linha deve ser o mais fina possível, então o ideal é que em cada coluna, exatamente um pixel seja pintado, e ainda, que esse pixel pintado, seja o que a reta real passe mais próximo.</p>

<p>Uma solução fácil de ser observada é começarmos a incrementar x, e para cada x nós calculamos o y através da equação da reta, e arredondaríamos esse valor para um valor inteiro, dessa forma teríamos a coordenada y da qual a reta passa mais próximo, então pintaríamos esse pixel, e teríamos o seguinte:
<img src="https://soaresgabriel.github.io/TrabalhoICG/images/firstline.png" alt="Primeira Rasterização de Linha">
Esse é exatamente o resultado que queremos, mas observe que para cada iteração temos: mutiplição de decimais, soma de decimais, arredondamentos, e essas operações são muito caras, então essa resolução não é muito eficiente.</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/SoaresGabriel/TrabalhoICG">TrabalhoICG</a> is maintained by <a href="https://github.com/SoaresGabriel">SoaresGabriel</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
